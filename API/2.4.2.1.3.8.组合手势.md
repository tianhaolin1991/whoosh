# 组合手势

手势识别组合，即多种手势组合为复合手势，支持连续识别、并行识别和互斥识别。

```cangjie
import kit.UIkit.*
```
## Component Constructors

### public init(mode: GestureMode, gesture: Array<GestureType>)

```cangjie
public init(mode: GestureMode, gesture: Array<GestureType>)
```
功能： 创建一个手势识别组合。

**Parameters:**

| type | required | description | name | default |
| --- | --- | --- | --- | --- |
| GestureMode | 是 | 设置组合手势识别模式。 | mode | GestureMode.Sequence |
| TapGesture LongPressGesture PanGesture PinchGesture RotationGesture SwipeGesture GestureGroup | 是 | 设置1个或者多个基础手势类型时，这些手势会被识别为组合手势。若此参数Array长度为0则组合手势识别功能不生效。 说明： 当需要为一个组件同时添加单击和双击手势时，可在组合手势中添加两个TapGesture，需要双击手势在前，单击手势在后，否则不生效。 | gesture | - |


## Functions

### public func onCancel(callback: () -> Unit): This

```cangjie
public func onCancel(callback: () -> Unit): This
```
功能： 顺序组合手势（GestureMode.Sequence）取消后触发该事件。

**Parameters:**

| type | required | description | name | default |
| --- | --- | --- | --- | --- |
| () -> Unit | 是 | 回调函数，顺序组合手势（GestureMode.Sequence）取消后触发该回调。 | callback | - |


## Enums

### GestureMode

enum GestureMode
```cangjie
public enum GestureMode { | Sequence | Parallel | Exclusive }
```
功能： 组合手势的识别模式。

#### Sequence

```cangjie
Sequence
```
功能： 顺序识别，按照手势的注册顺序识别手势，直到所有手势识别成功。若有一个手势识别失败，后续手势识别均失败。顺序识别手势组仅有最后一个手势可以响应onActionEnd。

#### Parallel

```cangjie
Parallel
```
功能： 并发识别，注册的手势同时识别，直到所有手势识别结束，手势识别互相不影响。

#### Exclusive

```cangjie
Exclusive
```
功能： 互斥识别，注册的手势同时识别，若有一个手势识别成功，则结束手势识别。



## Examples

```cangjie
package ohos_app_cangjie_entry
import kit.UIKit.*
import ohos.state_macro_manage.*

@Entry
@Component
class EntryView {
 @State var count: Int64 = 0
 @State var offsetX: Float64 = 0.0
 @State var offsetY: Float64 = 0.0
 @State var positionX: Float64 = 0.0
 @State var positionY: Float64 = 0.0
 @State var borderStyles: BorderStyle = BorderStyle.Solid

 func build() {
 Column() {
 Column() {
 Text('sequence gesture\n' + 'LongPress onAction:' + this.count.toString() +
 '\nPanGesture offset:\nX: ' + this.offsetX.toString() + '\n' + 'Y: ' + this.offsetY.toString())
 }
 .height(200)
 .width(300)
 .padding(20)
 .border(width: 3.vp, style: this.borderStyles)
 .margin(20)
 .translate(x: this.offsetX, y: this.offsetY, z: 0.0)
 .gesture(
 GestureGroup(GestureMode.Sequence,
 [
 LongPressGesture(repeat: true)
 .onAction({ event: GestureEvent =>
 this.count++
 }),
 PanGesture()
 .onActionStart({ event: GestureEvent =>
 this.borderStyles = BorderStyle.Dashed
 })
 .onActionUpdate({ event: GestureEvent =>
 this.offsetX = this.positionX + event.offsetX
 this.offsetY = this.positionY + event.offsetY
 })
 .onActionEnd({ event: GestureEvent =>
 this.positionX = this.offsetX
 this.positionY = this.offsetY
 this.borderStyles = BorderStyle.Solid
 })
 ]
 )
 )
 }
 }
}
```

