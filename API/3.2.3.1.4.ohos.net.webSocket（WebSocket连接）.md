# ohos.net.webSocket（WebSocket连接）

使用WebSocket建立服务器与客户端的双向连接，需要先通过 createWebSocket 方法创建 WebSocket 对象，然后通过 connect 方法连接到服务器。 当连接成功后，客户端会收到 open 事件的回调，之后客户端就可以通过 send 方法与服务器进行通信。 当服务器发信息给客户端时，客户端会收到 message 事件的回调。当客户端不要此连接时，可以通过调用 close 方法主动断开连接，之后客户端会收到 close 事件的回调。

```cangjie
import kit.NetworkKit.*
```
## Functions

### public func createWebSocket(): WebSocket

```cangjie
public func createWebSocket(): WebSocket
```
功能： 创建一个WebSocket，里面包括建立连接、关闭连接、发送数据和订阅/取消订阅WebSocket连接的打开事件、接收到服务器消息事件、关闭事件和错误事件。

**Returns:**

| type | description |
| --- | --- |
| WebSocket | 返回一个WebSocket对象，里面包括connect、send、close、on和off方法。 |


## Classes

### CloseResult

class CloseResult
```cangjie
public class CloseResult { public CloseResult( public let code : UInt32, public let reason : String ) }
```
功能： 关闭WebSocket连接时，订阅close事件得到的关闭结果。

#### let code

```cangjie
public let code: UInt32
```
功能： 错误码，订阅close事件得到的关闭连接的错误码。
Type: UInt32; Readable: true; Writable: false

#### let reason

```cangjie
public let reason: String
```
功能： 原因值，订阅close事件得到的关闭连接的错误原因。
Type: String; Readable: true; Writable: false


### WebSocket

class WebSocket
```cangjie
public class WebSocket {}
```
功能： 在调用WebSocket的方法前，需要先通过 webSocket.createWebSocket 创建一个WebSocket。


### WebSocketAsyncCallback

class WebSocketAsyncCallback
```cangjie
open public class WebSocketAsyncCallback<T> <: Callback2Argument<Option<AsyncError>,Option<T>> { public WebSocketAsyncCallback(let f:(Option <AsyncError>, Option <T> ) -> Unit) }
```
功能： 打开事件的callback类型。


### WebSocketClientCert

class WebSocketClientCert
```cangjie
public class WebSocketClientCert { public WebSocketClientCert( public let certPath : String, public let keyPath : String, public let keyPassword !: ?String = None ) }
```
功能： 客户端证书类型。

#### let certPath

```cangjie
public let certPath: String
```
功能： 证书路径。
Type: String; Readable: true; Writable: false

#### let keyPassword

```cangjie
public let keyPassword: ?String = None
```
功能： 证书秘钥的密码。
Type: ?String; Readable: true; Writable: false

#### let keyPath

```cangjie
public let keyPath: String
```
功能： 证书秘钥的路径。
Type: String; Readable: true; Writable: false


### WebSocketCloseOptions

class WebSocketCloseOptions
```cangjie
public class WebSocketCloseOptions { public WebSocketCloseOptions( public let code !: UInt32 = 1000, public let reason !: String = "" ) }
```
功能： 关闭WebSocket连接时，可选参数的类型和说明。

#### let code

```cangjie
public let code: UInt32 = 1000
```
功能： 错误码，关闭WebSocket连接时的可选参数，可根据实际情况来填。默认值为1000。
Type: UInt32; Readable: true; Writable: false

#### let reason

```cangjie
public let reason: String = ""
```
功能： 原因值，关闭WebSocket连接时的可选参数，可根据实际情况来填。默认值为空字符串（""）。
Type: String; Readable: true; Writable: false


### WebSocketErrorCallback

class WebSocketErrorCallback
```cangjie
open public class WebSocketErrorCallback <: Callback1Argument<BusinessException> { public WebSocketErrorCallback(let f:(BusinessException) -> Unit) }
```
功能： Error事件的callback类型。


### WebSocketHttpProxy

class WebSocketHttpProxy
```cangjie
public class WebSocketHttpProxy { public WebSocketHttpProxy( public let host!: ?String = None, public let port!: ?UInt16 = None, public let exclusionList!: ?Array<String> = None, public let username!: ?String = None, public let password!: ?String = None ) }
```
功能： 网络代理配置信息。

#### let exclusionList

```cangjie
public let exclusionList: ?Array<String>= None
```
功能： 不使用代理的主机名列表。
Type: ?Array<String>; Readable: true; Writable: false

#### let host

```cangjie
public let host: ?String = None
```
功能： 代理服务器主机名。
Type: ?String; Readable: true; Writable: false

#### let password

```cangjie
public let password: ?String = None
```
功能： 使用代理的密码。
Type: ?String; Readable: true; Writable: false

#### let port

```cangjie
public let port: ?UInt16 = None
```
功能： 主机端口。
Type: ?UInt16; Readable: true; Writable: false

#### let username

```cangjie
public let username: ?String = None
```
功能： 使用代理的用户名。
Type: ?String; Readable: true; Writable: false


### WebSocketRequestOptions

class WebSocketRequestOptions
```cangjie
public class WebSocketRequestOptions { public WebSocketRequestOptions( public var header !: ?HashMap<String, String> = None, public var caPath !: String = "/etc/ssl/certs/cacert.pem", public var clientCert !: ?WebSocketClientCert = None, public var proxy !: ProxyConfiguration = SYSTEM, public var protocol !: String = "" ) }
```
功能： 建立WebSocket连接时，可选参数的类型和说明。

#### var caPath

```cangjie
public var caPath: String = "/etc/ssl/certs/cacert.pem"
```
功能： 如果设置了此参数，系统将使用用户指定路径的CA证书，(开发者需保证该路径下CA证书的可访问性)，否则将使用系统预设CA证书，系统预设CA证书位置：/etc/ssl/certs/cacert.pem。证书路径为沙箱映射路径（开发者可通过Global.getContext().filesDir获取应用沙箱路径）。目前仅支持格式为pem的文本证书。
Type: String; Readable: true; Writable: true

#### var clientCert

```cangjie
public var clientCert: ?WebSocketClientCert = None
```
功能： 支持传输客户端证书。
Type: ? WebSocketClientCert; Readable: true; Writable: true

#### var header

```cangjie
public var header: ?HashMap<String, String>= None
```
功能： 建立WebSocket连接可选参数，代表建立连接时携带的HTTP头信息。参数内容自定义，也可以不指定。
Type: ?HashMap<String,String>; Readable: true; Writable: true

#### var protocol

```cangjie
public var protocol: String = ""
```
功能： 自定义Sec-WebSocket-Protocol字段，默认为""。
Type: String; Readable: true; Writable: true

#### var proxy

```cangjie
public var proxy: ProxyConfiguration = SYSTEM
```
功能： 通信过程中的代理信息，默认使用系统网络代理。
Type: ProxyConfiguration; Readable: true; Writable: true



## Enums

### MessageData

enum MessageData
```cangjie
public enum MessageData <: ToString { | STRING_DATA(String) | ARRAY_DATA(Array<Byte>) | ... }
```
功能： 服务器消息事件的数据。

#### ARRAY_DATA(Array<Byte>)

```cangjie
ARRAY_DATA(Array<Byte>)
```
功能： 二进制数组。

#### STRING_DATA(String)

```cangjie
STRING_DATA(String)
```
功能： 字符串。


### OnOffType

enum OnOffType
```cangjie
public enum OnOffType <: Equatable<OnOffType> & ToString { | OPEN | MESSAGE | CLOSE | ERROR | DATAEND | HEADERRECEIVE | ... }
```
功能： WebSocket的订阅事件类型。

#### CLOSE

```cangjie
CLOSE
```
功能： 关闭事件类型。

#### DATAEND

```cangjie
DATAEND
```
功能： 数据接收结束事件类型。

#### ERROR

```cangjie
ERROR
```
功能： Error事件类型。

#### HEADERRECEIVE

```cangjie
HEADERRECEIVE
```
功能： HTTP Response Header事件类型。

#### MESSAGE

```cangjie
MESSAGE
```
功能： 服务器消息事件类型。

#### OPEN

```cangjie
OPEN
```
功能： 打开事件类型。


### ProxyConfiguration

enum ProxyConfiguration
```cangjie
public enum ProxyConfiguration { | NO_PROXY | SYSTEM | HTTPPROXY(WebSocketHttpProxy) | ... }
```
功能： 网络代理配置信息。

#### HTTPPROXY(WebSocketHttpProxy)

```cangjie
HTTPPROXY(WebSocketHttpProxy)
```
功能： 使用指定的网络代理。

#### NO_PROXY

```cangjie
NO_PROXY
```
功能： 不使用网络代理。

#### SYSTEM

```cangjie
SYSTEM
```
功能： 使用系统默认网络代理。


### ResponseHeaders

enum ResponseHeaders
```cangjie
public enum ResponseHeaders { | MAP_DATA(HashMap<String, String>) | ARRAY_STRING_DATA(Array<String>) | UNDEFINED_DATA | ... }
```
功能： 服务器发送的响应头。

#### ARRAY_STRING_DATA(Array<String>)

```cangjie
ARRAY_STRING_DATA(Array<String>)
```
功能： header数据类型为字符串数组。

#### MAP_DATA(HashMap<String, String>)

```cangjie
MAP_DATA(HashMap<String, String>)
```
功能： header数据类型为键值对。

#### UNDEFINED_DATA

```cangjie
UNDEFINED_DATA
```
功能： header数据类型为undefined。



## Examples

```cangjie
import kit.NetworkKit.*

class OpenCallBack <: WebSocketAsyncCallback<HashMap<UInt32, String>> {
 OpenCallBack(
 ) {
 super({errorCode: Option<AsyncError>, data: Option<HashMap<UInt32, String>> => })
 }
 public open func invoke(arg1: Option <AsyncError>, arg2: Option <HashMap<UInt32, String>>): Unit {
 AppLog.info("hello wrold!")
 }
}

class DataEndCallback <: Callback0Argument {
 let callback_: () -> Unit
 public init(callback: () -> Unit) {callback_ = callback}
 public open func invoke(): Unit {
 callback_()
 }
}

class ReceiveCallback <: Callback1Argument<ResponseHeaders> {
 let callback_: (arg: ResponseHeaders) -> Unit
 public init(callback: (arg: ResponseHeaders) -> Unit) {callback_ = callback}
 public open func invoke(arg: ResponseHeaders): Unit {
 callback_(arg)
 }
}

let options: WebSocketRequestOptions = WebSocketRequestOptions(
 header: HashMap<String, String>([("content-type", "application/json")]))
let availableWebSocketAddress: String = 'wss://ws.welive.huawei.com/'
let ws: WebSocket = createWebSocket()
// on open
let openCallBack = WebSocketAsyncCallback<HashMap<UInt32, String>>({
 errorCode: Option<AsyncError>, data: Option<HashMap<UInt32, String>> => match (errorCode) {
 case Some(e) => // error
 case _ => match (data) {
 case Some(value) =>
 ws.send(STRING_DATA("Hello, server!"),{errorCode: Option<AsyncError>, data: Option<Bool> => match (errorCode) {
 case Some(e) => // error
 case _ => match (data) {
 case Some(value) => // success
 case _ => // error
 }
 }})
 case _ => // error
 }
 }
})
ws.on(OnOffType.OPEN, openCallBack)

// on error
let errorCallBack = WebSocketErrorCallback({
 err: BusinessException => // ErrorCallback
})
ws.on(OnOffType.ERROR, errorCallBack)

// on message
let messageCallBack = WebSocketAsyncCallback<MessageData>({
 errorCode: Option<AsyncError>, data: Option<MessageData> => match (errorCode) {
 case Some(e) => // error
 case _ => match (data) {
 case Some(value) => // success
 case _ => // error
 }
 }
})
ws.on(OnOffType.MESSAGE, messageCallBack)

// on close
let closeCallBack = WebSocketAsyncCallback<CloseResult>({
 errorCode: Option<AsyncError>, data: Option<CloseResult> => match (errorCode) {
 case Some(e) => // error
 case _ => match (data) {
 case Some(value) => // success
 case _ => // error
 }
 }
})
ws.on(OnOffType.CLOSE, closeCallBack)

// on dataEnd
ws.on(OnOffType.DATAEND, DataEndCallback({ => // success
 }))

// on headerReceive
ws.on(OnOffType.HEADERRECEIVE, ReceiveCallback({
 data: ResponseHeaders => // success
 }))
ws.connect(availableWebSocketAddress, {errorCode: Option<AsyncError>, data: Option<Bool> => match (errorCode) {
 case Some(e) => // error
 case _ => match (data) {
 case Some(value) => // success
 case _ => // error
 }
}}, options: options)
```

